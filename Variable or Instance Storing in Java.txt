as we said, we can create methods in Java to perform specific functions, we can also create variables to use them as containers that can either
store the actual value inside of memory or just refer in memory directly. But this time we will understand where
do variables/Object instances "Go" when they are declared or initialized at some lines. There are different common JVM (Java Virtual Machine) Runtime Data Areas
Responsible for this (such as Stack, Heap, Method area or metaspace as it is called in latest JVM)
What each of them does:
- Heap: Stores Object instances, memory, contains Garbage Collectors
- Stack: Stores names of variables/Objects that are declared locally. partially stores some values
- Method area (metaspace): stores methods itself or variables/Objects that are part of the method.
Example:
public class Main {
   public static void main(String[] args) {
        int x = 5; 
    }
}
an 'int' is a type-info for the compiler, it does not go anywhere but it specifies to the compiler that 'x' variable is int type. 
However this time we declared this int 'x' variable inside of main method, those basically 'x' is declared locally, so it goes on the Stack along with the value 5.
But its important to understand that sometimes variables/Object instances can be declared as static, so they become part of the
method instead of going in heap even if variable is not local.
Example:
public class Main {
      public static int x = 5; 
    public static void main(String[] args) {
         
   }
}
Yes, this 'x' variable should go in Heap However it won't because its static, it is part of the method. so it goes in Method Area instead of
Heap. But if variable or instance is not part of the method, then it will indeed be stored in a Heap.
Example:
public class Main {
   public int x = 5;
   public static void main(String[] args) {
   } 
}
now 'public' still stays as type-info for compiler and 'int' as well, but 'x' and value of 5 goes in the Heap. But now lets speak about a methods
itself:
public class Main {
   public static void main(String[] args) {
        create();     
    }
    public static void create() {
    }
}
that method declaration goes in a Method area but create() call frame that is present locally in a main method goes in a Stack. 
But what about a case when method is called in a constructor?
public class Main {
     private Main() {
         create();  
     } 
     public static void main(String[] args) {
           new Main();
    }
    public void create() {
    }
}
Now 'create' method declaration goes in a method area again, even if Constructors are not classic methods by themselves,
Java still treats them similarly to how it does with methods. The create() call frame goes on a Stack again.
but new Main() inside of main method goes in a Heap. same goes for All Object instances that are not created locally or are not part of the method:
public class Main {
   public static void main(String[] args) {
        MyObject mo = new MyObject(); 
    }
}
or it can be stored in a Heap as well:
public class Main {
     public MyObject mo = new MyObject();   
     public static void main(String[] args) {
    }
}
But once MyObject instance will become static, now it is a part of method so it will go in a Method area:
public class Main {
     public static MyObject mo = new MyObject();   
       public static void main(String[] args) {
            
   }
}
So in a simple words, it's about understanding where do those Variables and Object instances go.
